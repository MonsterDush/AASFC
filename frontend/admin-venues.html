<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <link rel="stylesheet" href="/styles.css" />
  <title>Axelio · Admin Venues</title>
  <style>
    .toolbar { display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin:12px 0; }
    .card { border:1px solid rgba(0,0,0,.12); border-radius:12px; padding:10px 12px; margin:8px 0; }
    .row { display:flex; justify-content:space-between; gap:12px; align-items:center; flex-wrap:wrap; }
    .muted { opacity:.7; }
    .btn { cursor:pointer; }
    input[type="text"] { padding:10px; border-radius:10px; border:1px solid rgba(0,0,0,.2); min-width:240px; }
    pre { white-space:pre-wrap; word-break:break-word; }
  </style>
</head>

<body>
  <div class="container">
    <div class="topbar">
      <div class="brand">Axelio · Admin</div>
      <div class="muted">Venues</div>
    </div>

    <div class="toolbar">
      <button id="btnLogin" class="btn">Login</button>
      <button id="btnLoadActive" class="btn">Load active</button>
      <button id="btnLoadArchived" class="btn">Load archived</button>
      <span id="status" class="muted"></span>
    </div>

    <div class="card">
      <div class="row">
        <div>
          <div class="muted">Create venue (name + owner usernames через запятую)</div>
        </div>
      </div>
      <div class="toolbar">
        <input id="vName" type="text" placeholder="Venue name" />
        <input id="owners" type="text" placeholder="owner_usernames: ivan, petr" />
        <button id="btnCreate" class="btn">Create</button>
      </div>
      <div id="createResult" class="muted"></div>
    </div>

    <div id="list"></div>

    <div class="card">
      <div class="muted">Debug</div>
      <pre id="debug"></pre>
    </div>
  </div>

<script>
(() => {
  const API = "https://api-dev.axelio.ru";
  const statusEl = document.getElementById("status");
  const listEl = document.getElementById("list");
  const debugEl = document.getElementById("debug");
  const createResultEl = document.getElementById("createResult");

  function setStatus(s) { statusEl.textContent = s || ""; }
  function logDebug(obj) {
    try { debugEl.textContent = JSON.stringify(obj, null, 2); }
    catch { debugEl.textContent = String(obj); }
  }
  function safeText(x) { return (x === null || x === undefined) ? "" : String(x); }

  function getInitData() {
    try {
      const tg = window.Telegram && window.Telegram.WebApp;
      tg && tg.ready && tg.ready();
      return (tg && typeof tg.initData === "string") ? tg.initData : "";
    } catch {
      return "";
    }
  }

  async function apiFetch(path, opts = {}) {
    const url = API + path;
    const res = await fetch(url, {
      method: opts.method || "GET",
      headers: Object.assign({ "Content-Type": "application/json" }, opts.headers || {}),
      credentials: "include",
      body: opts.body ? JSON.stringify(opts.body) : undefined,
    });

    const text = await res.text();
    let data;
    try { data = text ? JSON.parse(text) : null; }
    catch { data = text; }

    if (!res.ok) {
      const err = new Error(`HTTP ${res.status} ${res.statusText}`);
      err.status = res.status;
      err.data = data;
      throw err;
    }
    return data;
  }

  async function login() {
    setStatus("Logging in...");
    const initData = getInitData();
    if (!initData) {
      setStatus("No initData. Open via Telegram Mini App.");
      logDebug({ error: "NO_INITDATA", hint: "Open page from Telegram Mini App, not regular browser." });
      return { ok: false };
    }
    try {
      const data = await apiFetch("/auth/telegram", {
        method: "POST",
        body: { initData: initData }
      });
      setStatus("Login OK");
      logDebug({ login: "OK", response: data });
      return { ok: true, data };
    } catch (e) {
      setStatus("Login failed");
      logDebug({ login: "FAILED", message: e.message, status: e.status, data: e.data });
      return { ok: false, error: e };
    }
  }

  function renderVenues(items) {
    listEl.innerHTML = "";
    if (!Array.isArray(items) || items.length === 0) {
      listEl.innerHTML = `<div class="muted">No venues</div>`;
      return;
    }

    for (const v of items) {
      const id = safeText(v.id);
      const name = safeText(v.name);
      const isArchived = !!v.is_archived;

      const div = document.createElement("div");
      div.className = "card";
      div.innerHTML = `
        <div class="row">
          <div>
            <div><b>${name}</b></div>
            <div class="muted">id=${id} · archived=${isArchived}</div>
          </div>
          <div class="toolbar">
            <button class="btn" data-action="rename" data-id="${id}">Rename</button>
            <button class="btn" data-action="toggleArchive" data-id="${id}" data-arch="${isArchived ? "1":"0"}">
              ${isArchived ? "Unarchive" : "Archive"}
            </button>
            <button class="btn" data-action="delete" data-id="${id}">Delete</button>
          </div>
        </div>
      `;
      listEl.appendChild(div);
    }
  }

  async function loadVenues(archived) {
    setStatus("Loading venues...");
    try {
      const items = await apiFetch(`/venues?archived=${archived ? "true" : "false"}`);
      renderVenues(items);
      setStatus("Loaded");
      logDebug({ load: "OK", count: Array.isArray(items) ? items.length : null });
    } catch (e) {
      setStatus("Load failed");
      listEl.innerHTML = `<div class="card"><b>Error</b><pre>${safeText(e.message)}\n\n${safeText(JSON.stringify(e.data, null, 2))}</pre></div>`;
      logDebug({ load: "FAILED", message: e.message, status: e.status, data: e.data });
    }
  }

  async function createVenue() {
    const name = document.getElementById("vName").value.trim();
    const ownersRaw = document.getElementById("owners").value.trim();
    const owner_usernames = ownersRaw
      ? ownersRaw.split(",").map(s => s.trim()).filter(Boolean)
      : [];

    createResultEl.textContent = "";
    setStatus("Creating venue...");

    try {
      const out = await apiFetch("/venues", {
        method: "POST",
        body: { name, owner_usernames }
      });
      setStatus("Created");
      createResultEl.textContent = "Created: " + safeText(out && (out.id || out.name || JSON.stringify(out)));
      await loadVenues(false);
      logDebug({ create: "OK", response: out });
    } catch (e) {
      setStatus("Create failed");
      createResultEl.textContent = `Error: ${safeText(e.message)} ${e.status ? "(HTTP " + e.status + ")" : ""}`;
      logDebug({ create: "FAILED", message: e.message, status: e.status, data: e.data });
    }
  }

  async function handleAction(ev) {
    const btn = ev.target.closest("button[data-action]");
    if (!btn) return;

    const action = btn.dataset.action;
    const id = btn.dataset.id;

    if (action === "rename") {
      const newName = prompt("New venue name?");
      if (!newName) return;
      setStatus("Renaming...");
      try {
        const out = await apiFetch(`/venues/${encodeURIComponent(id)}`, { method: "PATCH", body: { name: newName }});
        setStatus("Renamed");
        logDebug({ rename: "OK", response: out });
        await loadVenues(false);
      } catch (e) {
        setStatus("Rename failed");
        logDebug({ rename: "FAILED", message: e.message, status: e.status, data: e.data });
        alert(`Rename failed: ${e.message}`);
      }
    }

    if (action === "toggleArchive") {
      const isArchived = btn.dataset.arch === "1";
      setStatus(isArchived ? "Unarchiving..." : "Archiving...");
      try {
        const out = await apiFetch(`/venues/${encodeURIComponent(id)}/${isArchived ? "unarchive" : "archive"}`, { method: "POST" });
        setStatus("OK");
        logDebug({ archiveToggle: "OK", response: out });
        await loadVenues(isArchived); // после unarchive остаёмся на archived, после archive остаёмся на active — норм
      } catch (e) {
        setStatus("Archive toggle failed");
        logDebug({ archiveToggle: "FAILED", message: e.message, status: e.status, data: e.data });
        alert(`Archive toggle failed: ${e.message}`);
      }
    }

    if (action === "delete") {
      if (!confirm("Delete venue? (only should work if archived)")) return;
      setStatus("Deleting...");
      try {
        const out = await apiFetch(`/venues/${encodeURIComponent(id)}`, { method: "DELETE" });
        setStatus("Deleted");
        logDebug({ delete: "OK", response: out });
        await loadVenues(true);
      } catch (e) {
        setStatus("Delete failed");
        logDebug({ delete: "FAILED", message: e.message, status: e.status, data: e.data });
        alert(`Delete failed: ${e.message}`);
      }
    }
  }

  // Wire buttons
  document.getElementById("btnLogin").addEventListener("click", login);
  document.getElementById("btnLoadActive").addEventListener("click", () => loadVenues(false));
  document.getElementById("btnLoadArchived").addEventListener("click", () => loadVenues(true));
  document.getElementById("btnCreate").addEventListener("click", createVenue);
  listEl.addEventListener("click", handleAction);

  // Auto-boot: login -> load active
  (async () => {
    const r = await login();
    if (r.ok) await loadVenues(false);
  })();
})();
</script>
</body>
</html>
